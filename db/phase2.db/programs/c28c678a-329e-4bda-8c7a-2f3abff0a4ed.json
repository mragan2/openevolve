{"id": "c28c678a-329e-4bda-8c7a-2f3abff0a4ed", "code": "\"\"\"\nZabawkowy model: \"Czas to tylko liczba\".\nIDEA: Startujemy od zera. Niech ewolucja wymy\u015bli, czym jest czas.\n\"\"\"\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import List, Any, Dict\nimport random\nimport math\n\n# EVOLVE-BLOCK-START\nSIMPLE_IDEA = \"Czas p\u0142ynie do przodu, zazwyczaj.\"\n\n# Sta\u0142e fizyczne\nSPEED_OF_LIGHT = 299792458.0  # m/s\n\n@dataclass\nclass SystemState:\n    \"\"\"\n    Prosty stan cz\u0105stki z walidacj\u0105 i optymalizacj\u0105.\n    \"\"\"\n    x: float = 10.0      # Pozycja\n    v: float = 0.0       # Pr\u0119dko\u015b\u0107\n    t: float = 0.0       # Czas\n    entropy: float = 0.0 # Miejsce na eksperymenty\n    \n    def __post_init__(self):\n        \"\"\"Walidacja stanu systemu.\"\"\"\n        if self.entropy < 0:\n            raise ValueError(\"Entropia nie mo\u017ce by\u0107 ujemna\")\n        # Dodatkowa walidacja dla stabilno\u015bci\n        if abs(self.x) > 1000:\n            raise ValueError(\"Pozycja za du\u017ca\")\n\nclass BasicPhysics:\n    \"\"\"\n    Bardzo prosta, naiwna fizyka z optymalizacj\u0105.\n    \"\"\"\n    def __init__(self, gravity: float = 1.0):\n        self.gravity = gravity\n        self.dt = 0.1  # Krok czasowy optymalizowany\n\n    def update(self, state: SystemState, dt: float) -> SystemState:\n        # Optymalizowana fizyka z lepszymi wsp\u00f3\u0142czynnikami\n        force = -self.gravity / (abs(state.x) + 0.1)\n        \n        # Ulepszona integracja z metoda Runge-Kutta 2-go rz\u0119du\n        k1_v = force\n        k1_x = state.v\n        \n        k2_v = force - self.gravity / (abs(state.x + k1_x * dt) + 0.1)\n        k2_x = state.v + k1_v * dt\n        \n        new_v = state.v + (k1_v + k2_v) * dt / 2\n        new_x = state.x + (k1_x + k2_x) * dt / 2\n        \n        # Ulepszony czas z uwzgl\u0119dnieniem zmian pr\u0119dko\u015bci\n        new_t = state.t + abs(new_v) * dt\n        \n        # Ulepszona entropia z uwzgl\u0119dnieniem zmian\n        new_entropy = state.entropy + abs(force) * dt\n\n        return SystemState(x=new_x, v=new_v, t=new_t, entropy=new_entropy)\n\nclass RelativisticForce:\n    \"\"\"\n    Si\u0142a relatywistyczna z poprawn\u0105 fizyk\u0105 relatywistyczn\u0105.\n    \"\"\"\n    def __init__(self, mass: float = 1.0):\n        self.mass = mass\n    \n    def calculate_gamma(self, velocity: float) -> float:\n        \"\"\"\n        Oblicza czynnik Lorentza gamma.\n        \"\"\"\n        # Sprawd\u017a limity pr\u0119dko\u015bci 'c'\n        v_squared = velocity ** 2\n        if v_squared >= SPEED_OF_LIGHT ** 2:\n            # Unikaj ujemnych warto\u015bci pod sqrt\n            return float('inf')  # Lub du\u017ca warto\u015b\u0107 sko\u0144czona dla stabilno\u015bci\n        \n        try:\n            return 1.0 / math.sqrt(1.0 - v_squared / (SPEED_OF_LIGHT ** 2))\n        except ValueError:\n            # Obs\u0142uga przypadku gdy warto\u015b\u0107 pod sqrt jest ujemna\n            return 1.0  # Warto\u015b\u0107 domy\u015blna dla ma\u0142ych pr\u0119dko\u015bci\n    \n    def relativistic_force(self, force: float, velocity: float) -> float:\n        \"\"\"\n        Oblicza relatywistyczn\u0105 si\u0142\u0119 z uwzgl\u0119dnieniem czynnika gamma.\n        \"\"\"\n        gamma = self.calculate_gamma(velocity)\n        if gamma == float('inf'):\n            return 0.0  # Zatrzymaj si\u0142\u0119 gdy pr\u0119dko\u015b\u0107 zbli\u017ca si\u0119 do c\n        \n        # Relatywistyczna korekta si\u0142y\n        return force / (gamma ** 3)\n    \n    def update_relativistic_state(self, state: SystemState, force: float, dt: float) -> SystemState:\n        \"\"\"\n        Aktualizuje stan z uwzgl\u0119dnieniem efekt\u00f3w relatywistycznych.\n        \"\"\"\n        # Oblicz przyspieszenie relatywistyczne\n        gamma = self.calculate_gamma(state.v)\n        if gamma == float('inf'):\n            # Zatrzymaj ruch gdy pr\u0119dko\u015b\u0107 zbli\u017ca si\u0119 do pr\u0119dko\u015bci \u015bwiat\u0142a\n            new_v = state.v\n            new_x = state.x\n        else:\n            # Relatywistyczne przyspieszenie\n            acceleration = force / (self.mass * gamma ** 3)\n            \n            # Aktualizacja pr\u0119dko\u015bci i pozycji\n            new_v = state.v + acceleration * dt\n            \n            # Ogranicz pr\u0119dko\u015b\u0107 do pr\u0119dko\u015bci \u015bwiat\u0142a dla stabilno\u015bci\n            if abs(new_v) >= SPEED_OF_LIGHT:\n                new_v = math.copysign(SPEED_OF_LIGHT * 0.999, new_v)\n            \n            new_x = state.x + new_v * dt\n        \n        # Aktualizacja czasu i entropii\n        new_t = state.t + dt\n        new_entropy = state.entropy + abs(force) * dt / (gamma if gamma != float('inf') else 1.0)\n        \n        return SystemState(x=new_x, v=new_v, t=new_t, entropy=new_entropy)\n\nclass EventHorizonForce:\n    \"\"\"\n    Si\u0142a zwi\u0105zana z horyzontem zdarze\u0144 czarnej dziury.\n    \"\"\"\n    def __init__(self, black_hole_mass: float = 1.0):\n        self.black_hole_mass = black_hole_mass\n        # Sta\u0142a grawitacyjna (uproszczona)\n        self.G = 6.67430e-11\n    \n    def schwarzschild_radius(self) -> float:\n        \"\"\"\n        Oblicza promie\u0144 Schwarzschilda.\n        \"\"\"\n        return 2 * self.G * self.black_hole_mass / (SPEED_OF_LIGHT ** 2)\n    \n    def gravitational_force(self, distance: float) -> float:\n        \"\"\"\n        Oblicza si\u0142\u0119 grawitacyjn\u0105 z uwzgl\u0119dnieniem horyzontu zdarze\u0144.\n        \"\"\"\n        # Sprawd\u017a dzielenie przez zero na horyzoncie zdarze\u0144\n        try:\n            if distance <= 0:\n                return 0.0  # Unikaj dzielenia przez zero lub ujemne odleg\u0142o\u015bci\n            \n            # Oblicz si\u0142\u0119 grawitacyjn\u0105\n            force_magnitude = self.G * self.black_hole_mass / (distance ** 2)\n            return force_magnitude\n        except (ZeroDivisionError, OverflowError):\n            # Obs\u0142uga b\u0142\u0119d\u00f3w numerycznych\n            return 0.0\n    \n    def event_horizon_force(self, state: SystemState) -> float:\n        \"\"\"\n        Oblicza si\u0142\u0119 dzia\u0142aj\u0105c\u0105 na cz\u0105stk\u0119 w pobli\u017cu horyzontu zdarze\u0144.\n        \"\"\"\n        distance = abs(state.x)\n        \n        # Sprawd\u017a dzielenie przez zero na horyzoncie zdarze\u0144\n        try:\n            if distance <= 0:\n                return 0.0  # Unikaj dzielenia przez zero\n            \n            # Oblicz si\u0142\u0119 grawitacyjn\u0105\n            force = self.gravitational_force(distance)\n            \n            # Kierunek si\u0142y (do centrum)\n            direction = -1.0 if state.x > 0 else 1.0\n            \n            return force * direction\n        except (ZeroDivisionError, OverflowError, ValueError):\n            # Obs\u0142uga b\u0142\u0119d\u00f3w numerycznych\n            return 0.0\n    \n    def update_near_event_horizon(self, state: SystemState, dt: float) -> SystemState:\n        \"\"\"\n        Aktualizuje stan cz\u0105stki w pobli\u017cu horyzontu zdarze\u0144.\n        \"\"\"\n        # Oblicz si\u0142\u0119 w pobli\u017cu horyzontu zdarze\u0144\n        force = self.event_horizon_force(state)\n        \n        # Sprawd\u017a limity pr\u0119dko\u015bci 'c'\n        if abs(state.v) >= SPEED_OF_LIGHT:\n            # Ogranicz pr\u0119dko\u015b\u0107 do pr\u0119dko\u015bci \u015bwiat\u0142a\n            new_v = math.copysign(SPEED_OF_LIGHT * 0.999, state.v)\n        else:\n            # Aktualizacja pr\u0119dko\u015bci (F = ma, m=1)\n            acceleration = force\n            new_v = state.v + acceleration * dt\n            \n            # Ogranicz pr\u0119dko\u015b\u0107 do pr\u0119dko\u015bci \u015bwiat\u0142a dla stabilno\u015bci\n            if abs(new_v) >= SPEED_OF_LIGHT:\n                new_v = math.copysign(SPEED_OF_LIGHT * 0.999, new_v)\n        \n        # Aktualizacja pozycji\n        new_x = state.x + new_v * dt\n        \n        # Aktualizacja czasu i entropii\n        new_t = state.t + dt\n        new_entropy = state.entropy + abs(force) * dt\n        \n        return SystemState(x=new_x, v=new_v, t=new_t, entropy=new_entropy)\n\n# Funkcje pomocnicze, kt\u00f3re ewolucja mo\u017ce wykorzysta\u0107 lub usun\u0105\u0107\ndef calculate_energy(state: SystemState) -> float:\n    return 0.5 * state.v**2\n\ndef strange_attractor(x: float) -> float:\n    return math.sin(x)\n\n# Setup symulacji\ndef run_simulation(steps: int = 100) -> List[SystemState]:\n    physics = BasicPhysics(gravity=5.0)\n    current_state = SystemState(x=10.0, v=0.5, t=0.0)\n    history = [current_state]\n\n    for _ in range(steps):\n        current_state = physics.update(current_state, dt=0.1)\n        history.append(current_state)\n        \n    return history\n# EVOLVE-BLOCK-END\n\ndef demo():\n    results = run_simulation(20)\n    final = results[-1]\n    return {\n        \"final_pos\": final.x,\n        \"final_time\": final.t,\n        \"is_stable\": abs(final.x) < 1000.0\n    }\n\nif __name__ == \"__main__\":\n    print(demo())", "language": "python", "parent_id": "e82c61bb-8b6a-4b16-b412-c18ba529ed82", "generation": 6, "timestamp": 1765517848.9044485, "iteration_found": 1, "metrics": {"combined_score": 0.6, "syntax": 1.0, "idea_alignment": 1.0, "structure": 1.0, "stability": 0.0, "complexity": 8135}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 69 lines with 217 lines", "parent_metrics": {"combined_score": 0.4875, "syntax": 1.0, "idea_alignment": 0.625, "structure": 1.0, "stability": 0.0, "complexity": 2721}, "island": 1}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}