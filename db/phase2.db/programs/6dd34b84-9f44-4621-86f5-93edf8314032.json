{"id": "6dd34b84-9f44-4621-86f5-93edf8314032", "code": "\"\"\"\nZabawkowy model: \"Czas to tylko liczba\".\nIDEA: Startujemy od zera. Niech ewolucja wymy\u015bli, czym jest czas.\n\"\"\"\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import List, Any, Dict\nimport random\nimport math\n\n# EVOLVE-BLOCK-START\nSIMPLE_IDEA = \"Czas p\u0142ynie do przodu, zazwyczaj.\"\n\n@dataclass\nclass SystemState:\n    \"\"\"\n    Stan fizyczny systemu z uwzgl\u0119dnieniem czasu i energii.\n    \"\"\"\n    x: float = 10.0      # Pozycja w przestrzeni\n    v: float = 0.0       # Pr\u0119dko\u015b\u0107\n    t: float = 0.0       # Aktualny czas symulacji\n    entropy: float = 0.0 # Entropia systemu\n    energy: float = 0.0  # Energia uk\u0142adu\n\nclass BasicPhysics:\n    \"\"\"\n    Bardzo prosta, naiwna fizyka.\n    Brak relatywistyki, brak limit\u00f3w, brak ochrony.\n    \"\"\"\n    def __init__(self, gravity: float = 1.0):\n        self.gravity = gravity\n\n    def update(self, state: SystemState, dt: float) -> SystemState:\n        # 1. Zwyk\u0142a fizyka (F = ma)\n        # Si\u0142a ci\u0105gnie do zero (jak grawitacja)\n        # Dzielenie przez zero - ochrona\n        denom = state.x * state.x\n        if abs(denom) < 1e-10:\n            denom = 1e-10\n        force = -self.gravity / denom\n        \n        # 2. Naiwna integracja\n        new_v = state.v + force * dt\n        new_x = state.x + new_v * dt\n        \n        # 3. Czas jest liniowy (NUDNE! Ewolucja powinna to zmieni\u0107)\n        new_t = state.t + dt\n        \n        # 4. Entropia ro\u015bnie z si\u0142\u0105\n        new_entropy = state.entropy + abs(force) * dt * 0.01\n        \n        # 5. Energia kinetyczna\n        new_energy = 0.5 * new_v * new_v\n\n        return SystemState(x=new_x, v=new_v, t=new_t, entropy=new_entropy, energy=new_energy)\n\n# Sta\u0142e fizyczne\nSPEED_OF_LIGHT = 299792458.0  # m/s\n\nclass RelativisticForce:\n    \"\"\"\n    Si\u0142a relatywistyczna z poprawn\u0105 fizyk\u0105 relatywistyczn\u0105 i stabilno\u015bci\u0105 numeryczn\u0105.\n    \"\"\"\n    def __init__(self, mass: float = 1.0):\n        self.mass = mass\n    \n    def calculate_gamma(self, velocity: float) -> float:\n        \"\"\"\n        Oblicza czynnik Lorentza gamma z ochron\u0105 przed b\u0142\u0119dami numerycznymi.\n        \"\"\"\n        # Sprawd\u017a limity pr\u0119dko\u015bci 'c'\n        v_squared = velocity ** 2\n        c_squared = SPEED_OF_LIGHT ** 2\n        \n        # Ogranicz pr\u0119dko\u015b\u0107 do nieco poni\u017cej pr\u0119dko\u015bci \u015bwiat\u0142a dla stabilno\u015bci\n        if v_squared >= c_squared:\n            velocity = math.copysign(SPEED_OF_LIGHT * 0.999999, velocity)\n            v_squared = velocity ** 2\n        \n        try:\n            # Sprawd\u017a czy warto\u015b\u0107 pod sqrt jest dodatnia\n            denominator = 1.0 - v_squared / c_squared\n            if denominator <= 0:\n                return 1.0  # Zwr\u00f3\u0107 gamma=1 dla bardzo wysokich pr\u0119dko\u015bci\n            \n            sqrt_value = math.sqrt(denominator)\n            if sqrt_value == 0:\n                return 1e10  # Du\u017ca warto\u015b\u0107 gamma dla pr\u0119dko\u015bci bliskich c\n            \n            return 1.0 / sqrt_value\n        except (ValueError, ZeroDivisionError):\n            # Obs\u0142uga przypadku gdy warto\u015b\u0107 pod sqrt jest ujemna lub dzielenie przez zero\n            return 1.0  # Warto\u015b\u0107 domy\u015blna dla ma\u0142ych pr\u0119dko\u015bci\n    \n    def relativistic_force(self, force: float, velocity: float) -> float:\n        \"\"\"\n        Oblicza relatywistyczn\u0105 si\u0142\u0119 z uwzgl\u0119dnieniem czynnika gamma.\n        \"\"\"\n        gamma = self.calculate_gamma(velocity)\n        if not math.isfinite(gamma) or gamma > 1e10:  # Ograniczenie dla bardzo du\u017cych gamma\n            return 0.0  # Zatrzymaj si\u0142\u0119 gdy pr\u0119dko\u015b\u0107 zbli\u017ca si\u0119 do c\n        \n        # Relatywistyczna korekta si\u0142y\n        gamma_cubed = gamma ** 3\n        if not math.isfinite(gamma_cubed) or gamma_cubed > 1e15:\n            return 0.0\n            \n        try:\n            result = force / gamma_cubed\n            return result if math.isfinite(result) else 0.0\n        except (ZeroDivisionError, OverflowError):\n            return 0.0\n    \n    def update_relativistic_state(self, state: SystemState, force: float, dt: float) -> SystemState:\n        \"\"\"\n        Aktualizuje stan z uwzgl\u0119dnieniem efekt\u00f3w relatywistycznych.\n        \"\"\"\n        # Sprawd\u017a limity pr\u0119dko\u015bci 'c' przed obliczeniami\n        if abs(state.v) >= SPEED_OF_LIGHT:\n            state_v = math.copysign(SPEED_OF_LIGHT * 0.999999, state.v)\n        else:\n            state_v = state.v\n            \n        # Oblicz przyspieszenie relatywistyczne\n        gamma = self.calculate_gamma(state_v)\n        \n        # Sprawd\u017a czy gamma jest w granicach\n        if not math.isfinite(gamma) or gamma > 1e10:\n            # Zatrzymaj ruch gdy pr\u0119dko\u015b\u0107 zbli\u017ca si\u0119 do pr\u0119dko\u015bci \u015bwiat\u0142a\n            new_v = state_v\n            new_x = state.x\n        else:\n            # Relatywistyczne przyspieszenie\n            gamma_cubed = gamma ** 3\n            if not math.isfinite(gamma_cubed) or gamma_cubed > 1e15:\n                acceleration = 0.0\n            else:\n                try:\n                    acceleration = force / (self.mass * gamma_cubed)\n                    if not math.isfinite(acceleration):\n                        acceleration = 0.0\n                except (ZeroDivisionError, OverflowError):\n                    acceleration = 0.0\n            \n            # Aktualizacja pr\u0119dko\u015bci i pozycji\n            new_v = state_v + acceleration * dt\n            \n            # Ogranicz pr\u0119dko\u015b\u0107 do pr\u0119dko\u015bci \u015bwiat\u0142a dla stabilno\u015bci\n            if abs(new_v) >= SPEED_OF_LIGHT:\n                new_v = math.copysign(SPEED_OF_LIGHT * 0.999999, new_v)\n            \n            new_x = state.x + new_v * dt\n        \n        # Aktualizacja czasu i entropii\n        new_t = state.t + dt\n        gamma_for_entropy = gamma if math.isfinite(gamma) and gamma < 1e10 else 1.0\n        try:\n            entropy_change = abs(force) * dt / gamma_for_entropy\n            new_entropy = state.entropy + entropy_change if math.isfinite(entropy_change) else state.entropy\n        except (ZeroDivisionError, OverflowError):\n            new_entropy = state.entropy\n        \n        # Energia relatywistyczna\n        try:\n            gamma_energy = gamma_for_entropy if math.isfinite(gamma_for_entropy) else 1.0\n            new_energy = (gamma_energy - 1.0) * self.mass * SPEED_OF_LIGHT ** 2\n            if not math.isfinite(new_energy):\n                new_energy = state.energy if hasattr(state, 'energy') else 0.0\n        except (OverflowError, ValueError):\n            new_energy = state.energy if hasattr(state, 'energy') else 0.0\n        \n        return SystemState(x=new_x, v=new_v, t=new_t, entropy=new_entropy, energy=new_energy)\n\nclass EventHorizonForce:\n    \"\"\"\n    Si\u0142a zwi\u0105zana z horyzontem zdarze\u0144 czarnej dziury z poprawn\u0105 obs\u0142ug\u0105 numeryczn\u0105.\n    \"\"\"\n    def __init__(self, black_hole_mass: float = 1.0):\n        self.black_hole_mass = max(black_hole_mass, 1e-15)  # Ochrona przed ujemnymi masami\n        # Sta\u0142a grawitacyjna (uproszczona)\n        self.G = 6.67430e-11\n    \n    def schwarzschild_radius(self) -> float:\n        \"\"\"\n        Oblicza promie\u0144 Schwarzschilda.\n        \"\"\"\n        try:\n            # Sprawd\u017a dzielenie przez zero\n            if self.black_hole_mass <= 0:\n                return 1e-15\n            \n            c_squared = SPEED_OF_LIGHT ** 2\n            if c_squared <= 0:\n                return 1e-15\n                \n            result = 2 * self.G * self.black_hole_mass / c_squared\n            return result if math.isfinite(result) and result > 0 else 1e-15\n        except (ZeroDivisionError, OverflowError, ValueError):\n            return 1e-15  # Ma\u0142a warto\u015b\u0107 w przypadku b\u0142\u0119du\n    \n    def gravitational_force(self, distance: float) -> float:\n        \"\"\"\n        Oblicza si\u0142\u0119 grawitacyjn\u0105 z uwzgl\u0119dnieniem horyzontu zdarze\u0144.\n        \"\"\"\n        # Sprawd\u017a dzielenie przez zero na horyzoncie zdarze\u0144\n        try:\n            if distance <= 0 or not math.isfinite(distance):\n                return 0.0  # Unikaj dzielenia przez zero lub ujemne odleg\u0142o\u015bci\n            \n            # Oblicz si\u0142\u0119 grawitacyjn\u0105\n            distance_squared = distance ** 2\n            if distance_squared <= 0 or not math.isfinite(distance_squared):\n                return 0.0\n                \n            force_magnitude = self.G * self.black_hole_mass / distance_squared\n            \n            # Sprawd\u017a czy si\u0142a nie jest zbyt du\u017ca (numeryczna stabilno\u015b\u0107)\n            if not math.isfinite(force_magnitude):\n                return 0.0\n            elif abs(force_magnitude) > 1e20:\n                return math.copysign(1e20, force_magnitude)\n                \n            return force_magnitude\n        except (ZeroDivisionError, OverflowError, ValueError):\n            # Obs\u0142uga b\u0142\u0119d\u00f3w numerycznych\n            return 0.0\n    \n    def event_horizon_force(self, state: SystemState) -> float:\n        \"\"\"\n        Oblicza si\u0142\u0119 dzia\u0142aj\u0105c\u0105 na cz\u0105stk\u0119 w pobli\u017cu horyzontu zdarze\u0144.\n        \"\"\"\n        distance = abs(state.x)\n        \n        # Sprawd\u017a dzielenie przez zero na horyzoncie zdarze\u0144\n        try:\n            if distance <= 1e-15 or not math.isfinite(distance):  # Ochrona przed dzieleniem przez zero\n                return 0.0  # Unikaj dzielenia przez zero\n            \n            # Oblicz si\u0142\u0119 grawitacyjn\u0105\n            force = self.gravitational_force(distance)\n            \n            # Sprawd\u017a czy wynik jest poprawny\n            if not math.isfinite(force):\n                return 0.0\n            \n            # Kierunek si\u0142y (do centrum)\n            direction = -1.0 if state.x > 0 else 1.0\n            \n            result = force * direction\n            \n            # Sprawd\u017a czy wynik jest poprawny\n            if not math.isfinite(result):\n                return 0.0\n                \n            return result\n        except (ZeroDivisionError, OverflowError, ValueError):\n            # Obs\u0142uga b\u0142\u0119d\u00f3w numerycznych\n            return 0.0\n    \n    def update_near_event_horizon(self, state: SystemState, dt: float) -> SystemState:\n        \"\"\"\n        Aktualizuje stan cz\u0105stki w pobli\u017cu horyzontu zdarze\u0144.\n        \"\"\"\n        # Sprawd\u017a limity pr\u0119dko\u015bci 'c'\n        if abs(state.v) >= SPEED_OF_LIGHT:\n            # Ogranicz pr\u0119dko\u015b\u0107 do pr\u0119dko\u015bci \u015bwiat\u0142a\n            new_v = math.copysign(SPEED_OF_LIGHT * 0.999999, state.v)\n        else:\n            # Oblicz si\u0142\u0119 w pobli\u017cu horyzontu zdarze\u0144\n            force = self.event_horizon_force(state)\n            \n            # Aktualizacja pr\u0119dko\u015bci (F = ma, m=1)\n            acceleration = force\n            new_v = state.v + acceleration * dt\n            \n            # Ogranicz pr\u0119dko\u015b\u0107 do pr\u0119dko\u015bci \u015bwiat\u0142a dla stabilno\u015bci\n            if abs(new_v) >= SPEED_OF_LIGHT:\n                new_v = math.copysign(SPEED_OF_LIGHT * 0.999999, new_v)\n        \n        # Aktualizacja pozycji\n        new_x = state.x + new_v * dt\n        \n        # Sprawd\u017a czy cz\u0105stka nie przekroczy\u0142a horyzontu zdarze\u0144\n        schwarz_radius = self.schwarzschild_radius()\n        if abs(new_x) < schwarz_radius and schwarz_radius > 1e-15:\n            # Zatrzymaj cz\u0105stk\u0119 na horyzoncie\n            new_x = math.copysign(schwarz_radius, new_x)\n            new_v = 0.0\n        \n        # Aktualizacja czasu i entropii\n        new_t = state.t + dt\n        force = self.event_horizon_force(state)  # Ponowne obliczenie si\u0142y dla entropii\n        new_entropy = state.entropy + abs(force) * dt if math.isfinite(abs(force) * dt) else state.entropy\n        \n        # Energia potencjalna grawitacyjna\n        distance = abs(new_x)\n        try:\n            if distance > 1e-15 and math.isfinite(distance):\n                new_energy = -self.G * self.black_hole_mass / distance\n                if not math.isfinite(new_energy):\n                    new_energy = state.energy if hasattr(state, 'energy') else 0.0\n            else:\n                new_energy = state.energy if hasattr(state, 'energy') else -1e20  # Bardzo du\u017ca warto\u015b\u0107 ujemna\n        except (ZeroDivisionError, OverflowError, ValueError):\n            new_energy = state.energy if hasattr(state, 'energy') else -1e20\n        \n        return SystemState(x=new_x, v=new_v, t=new_t, entropy=new_entropy, energy=new_energy)\n\n# Funkcje pomocnicze, kt\u00f3re ewolucja mo\u017ce wykorzysta\u0107 lub usun\u0105\u0107\ndef calculate_energy(state: SystemState) -> float:\n    return 0.5 * state.v**2\n\ndef strange_attractor(x: float) -> float:\n    return math.sin(x)\n\n# Setup symulacji\ndef run_simulation(steps: int = 100) -> List[SystemState]:\n    physics = BasicPhysics(gravity=5.0)\n    current_state = SystemState(x=10.0, v=0.5, t=0.0)\n    history = [current_state]\n\n    for _ in range(steps):\n        current_state = physics.update(current_state, dt=0.1)\n        history.append(current_state)\n        \n    return history\n# EVOLVE-BLOCK-END\n\ndef demo():\n    results = run_simulation(20)\n    final = results[-1]\n    return {\n        \"final_pos\": final.x,\n        \"final_time\": final.t,\n        \"is_stable\": abs(final.x) < 1000.0,\n        \"final_energy\": final.energy,\n        \"final_entropy\": final.entropy\n    }\n\nif __name__ == \"__main__\":\n    # Uruchom symulacj\u0119 i wy\u015bwietl wyniki\n    results = demo()\n    print(\"Wyniki symulacji:\")\n    print(f\"Czas ko\u0144cowy: {results['final_time']:.2f}\")\n    print(f\"Pozycja ko\u0144cowa: {results['final_pos']:.4f}\")\n    print(f\"Energia ko\u0144cowa: {results['final_energy']:.4f}\")\n    print(f\"Stabilna: {results['is_stable']}\")\n    print(f\"Entropia ko\u0144cowa: {results['final_entropy']:.4f}\")", "language": "python", "parent_id": "c9ae0b09-2c4e-4480-821d-22101f0f3d50", "generation": 6, "timestamp": 1765518768.0411656, "iteration_found": 0, "metrics": {"combined_score": 0.6, "syntax": 1.0, "idea_alignment": 1.0, "structure": 1.0, "stability": 0.0, "complexity": 13242}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 84 lines with 113 lines\nChange 2: Replace 109 lines with 134 lines", "parent_metrics": {"combined_score": 0.6, "syntax": 1.0, "idea_alignment": 1.0, "structure": 1.0, "stability": 0.0, "complexity": 10630}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}