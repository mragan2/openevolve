{"id": "fba91342-fb89-4990-984e-f25fa38d9dc5", "code": "from __future__ import annotations\nfrom dataclasses import dataclass\nimport math\nfrom typing import List, Optional, Dict\nfrom random import gauss, random, seed\nimport time\n\n@dataclass\nclass SystemState:  # Complex system state with rich physical properties\n    x: float = 1.0          # Position along X-axis\n    v: float = 0.0           # Velocity in X direction\n    a: float = 0.0          # Acceleration\n    t: float = 0.0           # Proper time\n    p: float = 1.0           # Momentum\n    r: float = 0.0           # Potential energy\n    m: float = 1.0           # Relativistic mass\n    q: float = 0.0           # Electric charge\n    E: float = 0.0           # Electric field (vector) - simplified to scalar for simplicity\n    B: float = 0.0           # Magnetic field (vector) - simplified to scalar for simplicity\n    s: float = 0.0           # Spin-like degree of freedom\n    entropy: float = 0.0     # Information entropy (bits)\n    \n    def __post_init__(self):\n        \"\"\"Initialize with more realistic initial conditions\"\"\"\n        if self.x == 1.0:  # Default initial state\n            self.v = 0.1\n            self.p = self.m * self.v\n            self.entropy = 1.0  # Non-zero entropy\n    \n    def to_dict(self) -> Dict:\n        \"\"\"Convert to dictionary for easier inspection\"\"\"\n        return {\n            'x': self.x,\n            'v': self.v,\n            'a': self.a,\n            't': self.t,\n            'p': self.p,\n            'r': self.r,\n            'm': self.m,\n            'q': self.q,\n            'E': self.E,\n            'B': self.B,\n            's': self.s,\n            'entropy': self.entropy\n        }\n\nclass ComplexPhysics:\n    def __init__(self, \n                 grav_const=6.67e-11,  # Gravitational constant\n                 speed_oft_light=2.998e8, # Speed of light\n                 boltzmann_k=1.38e-23,   # Boltzmann constant\n                 elementary_charge=1.6e-19): # Elementary charge\n        self.c = speed_oft_light\n        self.G = grav_const\n        self.k = boltzmann_k\n        self.e = elementary_charge\n        self.h = 6.626e-34  # Planck constant\n        \n    def calculate_force(self, state: SystemState) -> Dict[str, float]:\n        \"\"\"Calculate complex electromagnetic and gravitational forces\"\"\"\n        forces = {}\n        \n        # Gravitational force (F = G * m1 * m2 / r\u00b2)\n        # Using state.x as distance from origin\n        forces['gravitational'] = (self.G * (state.m ** 2)) / ((state.x ** 2 + 1e-10))\n        \n        # Electromagnetic force (simplified)\n        forces['electromagnetic'] = state.q * state.E\n        \n        # Lorentz force (simplified)\n        # Note: Simplified from 3D vector math to scalar\n        lorentz = state.q * (state.E + state.v * state.B)\n        forces['lorentz'] = lorentz\n        \n        # Relativistic correction\n        gamma = 1 / math.sqrt(1 - (state.v ** 2) / self.c ** 2) if state.v < self.c else float('inf')\n        forces['gamma'] = gamma\n        \n        return forces\n    \n    def update(self, state: SystemState, dt: float) -> SystemState:\n        \"\"\"Advance simulation state by dt\"\"\"\n        if dt <= 0:\n            raise ValueError(\"Time step must be positive\")\n        \n        # Calculate forces\n        forces = self.calculate_force(state)\n        \n        # Update kinematic variables\n        # Using simplified Newtonian mechanics with relativistic correction\n        new_v = state.v + forces['lorentz'] * dt\n        new_x = state.x + new_v * dt\n        \n        # Time dilation effect (simplified)\n        new_t = state.t + dt / forces['gamma']\n        \n        # Momentum and energy\n        new_p = (state.m * new_v) / math.sqrt(1 - (new_v ** 2) / self.c ** 2) if new_v < self.c else float('inf')\n        \n        # Potential energy\n        new_r = state.q * state.E\n        \n        # Quantum uncertainty (Schrodinger-like evolution)\n        uncertainty = gauss(0, 1e-4) * dt\n        \n        # Entropy increase (dS = dQ/T, dQ = dE/dt)\n        new_entropy = state.entropy + abs(new_p - state.p) * dt * 1e-3\n        \n        # Quantum decoherence\n        decoherence = gauss(0, 1e-6) * state.p\n        \n        return SystemState(\n            x=new_x, \n            v=new_v, \n            t=new_t, \n            p=new_p, \n            r=new_r,\n            m=state.m, \n            q=state.q, \n            E=state.E, \n            B=state.B,\n            s=state.s + uncertainty, \n            entropy=new_entropy,\n            a=new_p * (state.s + decoherence)\n        )\n    \n    def simulate_steps(self, steps: int = 100) -> List[SystemState]:\n        \"\"\"Run simulation for specified number of steps\"\"\"\n        if steps <= 0:\n            raise ValueError(\"Number of steps must be positive\")\n        \n        history = [SystemState()]\n        for _ in range(steps):\n            current = history[-1]\n            new_state = self.update(current, dt=0.1)\n            history.append(new_state)\n        return history\n\ndef run_simulation() -> Dict[str, float]:\n    \"\"\"Run a demonstration of the simulation\"\"\"\n    physics = ComplexPhysics()\n    try:\n        history = physics.simulate_steps(50)\n        final = history[-1]\n        return {\n            \"final_position\": abs(final.x),\n            \"final_time\": final.t,\n            \"final_momentum\": final.p,\n            \"is_stable\": abs(final.x) < 1000.0,\n            \"entropy\": final.entropy,\n            \"history_length\": len(history)\n        }\n    except Exception as e:\n        return {\"error\": str(e)}\n\nif __name__ == \"__main__\":\n    result = run_simulation()\n    print(result)", "language": "python", "parent_id": "970c73ae-1bf5-441c-9430-408e379d2851", "generation": 4, "timestamp": 1765512603.0493696, "iteration_found": 10, "metrics": {"combined_score": 0.0, "syntax": 1.0, "idea_alignment": 0.5, "runtime_stability": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"combined_score": 0.0, "syntax": 1.0, "idea_alignment": 0.5, "runtime_stability": 0.0}, "island": 1}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}