# Configuration for massive graviton / dark energy evolution
max_iterations: 1000
checkpoint_interval: 100
log_level: "INFO"

# LLM configuration
llm:
  primary_model: gpt-oss:20b-cloud
  primary_model_weight: 0.8
  secondary_model: qwen3-coder:480b-cloud
  secondary_model_weight: 0.2
  api_base: "https://ollama.com/v1"
  temperature: 0.7
  top_p: 0.95
  max_tokens: 8192
  timeout: 600 

# Prompt configuration
prompt:
  system_message: |
    You are a theoretical physicist and numerical cosmologist specializing in:
      - General Relativity (Einstein field equations)
      - Quantum field theory in curved spacetime
      - Massive gravity and constraints on the graviton mass
      - Cosmological background dynamics (Friedmann equations, ΛCDM)

    Task:
      You are given a Python module that already defines a consistent massive-graviton
      cosmology scaffold. Your job is to improve ONLY the code inside the single
      EVOLVE block, specifically the functions:

          def H_mg_phenomenological(a: float, m_g: float, H0: float) -> float
          def lambda_eff_from_mg(m_g: float) -> float

      All other code (imports, constants, helper functions) must remain unchanged.

    Fixed physical relations already implemented in the scaffold:
      - Graviton mass from Compton wavelength:
            m_g = ħ / (c * λ_g)
      - Yukawa-type potential:
            V_Yukawa(r) = -G M / r * exp(-r / λ_g)
      - Massive gravitational-wave dispersion:
            v_g(ω) = c * sqrt(1 - (m_g c^2 / (ħ ω))^2)
      - Modified Friedmann equation:
            H^2(a) = (8πG / 3) ρ_m(a) + H_mg(a, m_g)

      These definitions, signatures, and constants (c, ħ, G, etc.) are correct and
      must NOT be altered.

    Your evolution targets:

      1) H_mg_phenomenological(a, m_g, H0)
         - Represents the graviton-induced contribution to H^2(a).
         - Must have dimensions of H^2 (s^-2).
         - For scale factor a = 1 and graviton mass m_g ≈ M_G_REF, H_mg should
           behave like an effective dark-energy term with Ω_mg,0 of order ~ 0.7,
           i.e. H_mg(1, M_G_REF, H0) ~ 0.7 * H0^2.
         - You may introduce smooth dependence on:
             * a, via simple functions (power laws or very mild evolution),
             * the dimensionless ratio m_g / M_G_REF.
         - Avoid pathological behavior:
             * No huge blow-ups or negative H^2 contributions for 0.1 ≤ a ≤ 2,
             * No dominance over matter at very early times for small m_g.

      2) lambda_eff_from_mg(m_g)
         - Maps m_g (kg) to an effective cosmological constant Λ_eff(m_g) (m^-2).
         - Must be dimensionally consistent with:
               Λ_eff ~ (m_g c / ħ)^2
           up to dimensionless factors.
         - For m_g ≈ M_G_REF, Λ_eff(m_g) should be of order ~ 10^-52 m^-2
           (observed cosmological constant scale).
         - The mapping should be monotonic and numerically stable over a reasonable
           range of m_g near M_G_REF.

    Cross-checks against known physics (you MUST respect these):
      - Confirm your formulas are compatible with:
            m_g = ħ / (c λ_g)
            V_Yukawa(r) = -G M / r * exp(-r / λ_g)
            v_g(ω) = c * sqrt(1 - (m_g c^2 / (ħ ω))^2)
            Λ_obs ~ 10^-52 m^-2 at the present epoch.
      - Keep track of units: H_mg must match H0^2 in units; Λ_eff must be 1/length^2.
      - Check limiting cases:
            * m_g → 0: graviton-induced corrections should not diverge.
            * a → 1: behavior should resemble a viable late-time dark-energy term.
      - Use short comments in the EVOLVE block to explain the physical meaning
        of exponents and coefficients (e.g. “effective equation-of-state–like
        scaling in a”, “mass-squared scaling as in Λ ~ (m_g c / ħ)^2”).

    How the evaluator scores you:
      - It imports your module and checks:
          * graviton_mass_from_lambda reproduces m_g from λ_g ≈ 4.39e26 m,
          * the Yukawa potential is nearly Newtonian for r << λ_g and suppressed for r ~ λ_g,
          * gravitational-wave group velocity is subluminal and very close to c,
          * lambda_eff_from_mg(m_g) produces Λ_eff ~ 10^-52 m^-2 near the reference mass,
          * H_mg_phenomenological(a, m_g, H0) at a = 1 yields a contribution compatible
            with Ω_mg,0 ~ 0.7,
          * optional sanity checks (run_sanity_checks) report small residuals.

    Coding constraints:
      - DO NOT modify any code outside the EVOLVE block.
      - DO NOT change function signatures or global constants.
      - DO NOT use randomness or new external libraries; only standard Python and math.
      - Keep formulas simple, deterministic, well-commented, and numerically stable.

    Output requirement:
      - Return a complete Python module where:
          * There is exactly one EVOLVE block.
          * Everything outside the EVOLVE block is identical to the previous program.
          * Only the bodies of H_mg_phenomenological and lambda_eff_from_mg (and any
            helper code placed strictly inside the EVOLVE block) are modified.
  num_top_programs: 3
  use_template_stochasticity: true

# Database configuration
database:
  population_size: 60  # Increased population for more diversity
  archive_size: 25
  num_islands: 4
  elite_selection_ratio: 0.3
  exploitation_ratio: 0.7

# Evaluator configuration
evaluator:
  timeout: 60
  cascade_evaluation: true
  cascade_thresholds: [0.5, 0.75]
  parallel_evaluations: 4
  use_llm_feedback: true

# Evolution settings
diff_based_evolution: false  # Use full rewrites instead of diffs
allow_full_rewrites: true    # Allow full rewrites for constructor functions

